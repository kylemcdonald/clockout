<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>History - Clock-Out</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Inter', sans-serif;
        }
        body,
        html {
            margin: 0;
            padding: 0;
            height: auto;
            min-height: 100%;
            display: block;
            overflow: visible;
            overflow-y: auto;
            background-color: black;
            color: white;
        }
        .history-container {
            max-width: 1000px;
            margin: 80px auto 20px;
            padding: 20px;
            color: white;
        }
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        .history-header h1 {
            margin: 0;
            font-size: 1.5em;
            font-weight: normal;
        }
        .back-button {
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            font-size: 0.9em;
        }
        .back-button:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }
        .time-entry {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 4px;
            position: relative;
        }
        .time-entry::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: var(--visualization-width, 0%);
            height: 3px;
            background-color: var(--visualization-color, #D15540);
            border-radius: 4px 4px 0 0;
        }
        .time-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .project-name {
            font-weight: normal;
            font-size: 1em;
        }
        .project-name-colored {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 3px;
        }
        .duration {
            font-size: 1em;
            margin-right: 12px;
        }
        .time-range {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9em;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: rgba(255, 255, 255, 0.6);
        }
        .error {
            background-color: rgba(255, 0, 0, 0.15);
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .extend-button {
            padding: 6px 12px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 6px;
        }
        .extend-button:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }
        .edit-button,
        .split-button,
        .delete-button {
            padding: 0.5em;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 6px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
            min-height: 32px;
        }
        .edit-button:hover {
            background-color: rgba(59, 130, 246, 0.8);
        }
        .split-button:hover {
            background-color: rgba(168, 85, 247, 0.8);
        }
        .split-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .split-button:disabled:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .delete-button:hover {
            background-color: rgba(220, 53, 69, 0.8);
        }
        .edit-button svg,
        .split-button svg,
        .delete-button svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }
        .save-button {
            padding: 6px 12px;
            background-color: rgba(255, 255, 255, 0.15);
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 6px;
        }
        .save-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .cancel-button {
            padding: 6px 12px;
            background-color: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 6px;
        }
        .cancel-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .edit-mode .time-range {
            display: none;
        }
        .edit-mode .edit-form {
            display: block;
            margin-top: 12px;
        }
        .edit-form {
            display: none;
        }
        .edit-input {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 3px;
            padding: 6px 10px;
            color: white;
            font-size: 1em;
            margin-right: 8px;
            width: 200px;
        }
        .edit-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.3);
            background-color: rgba(255, 255, 255, 0.12);
        }
        .edit-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }
        .date-header {
            font-size: 1.2em;
            font-weight: normal;
            margin-top: 16px;
            margin-bottom: 8px;
        }
        .date-header:first-child {
            margin-top: 0;
        }
        .day-minimap {
            height: 1.2em;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
            margin-bottom: 2.5em;
            position: relative;
            overflow: visible;
            cursor: pointer;
        }
        .minimap-segment {
            overflow: hidden;
        }
        .day-minimap:hover {
            background-color: rgba(255, 255, 255, 0.08);
        }
        .day-entries {
            display: none;
        }
        .day-entries.expanded {
            display: block;
        }
        .minimap-segment {
            height: 100%;
            position: absolute;
            border-left: 2px solid black;
            top: 0;
        }
        .minimap-segment.untracked {
            background-color: rgba(102, 102, 102, 0.3);
        }
        .day-minimap-empty {
            border: 1px solid rgba(255, 255, 255, 0.3);
            background-color: transparent;
        }
        .hover-preview {
            position: absolute;
            top: 0;
            height: 100%;
            background-color: rgba(100, 150, 255, 0.3);
            pointer-events: none;
            border-radius: 2px;
        }
        .drag-selection {
            position: absolute;
            top: 0;
            height: 100%;
            background-color: rgba(100, 200, 100, 0.5);
            pointer-events: none;
            border-radius: 2px;
        }
        .time-indicator-start,
        .time-indicator-end {
            position: absolute;
            top: 100%;
            margin-top: 4px;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            white-space: nowrap;
            pointer-events: none;
            z-index: 100;
        }
        .time-indicator-start {
            transform: translateX(-100%);
        }
        .time-indicator-end {
            transform: translateX(0);
        }
        .project-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: black;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .project-modal.visible {
            display: flex;
        }
        .modal-close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 2em;
            cursor: pointer;
            padding: 10px;
            line-height: 1;
            z-index: 2001;
        }
        .modal-close-btn:hover {
            color: rgba(255, 255, 255, 0.7);
        }
        .project-modal-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 90vw;
            height: 90vh;
        }
        @media (orientation: portrait) {
            .project-modal-grid {
                grid-template-columns: repeat(3, 1fr);
                grid-template-rows: repeat(4, 1fr);
            }
        }
        @media (min-width: 1200px) and (orientation: landscape) {
            .project-modal-grid {
                grid-template-columns: repeat(5, 1fr);
                grid-template-rows: repeat(3, 1fr);
            }
        }
        @media (min-height: 1200px) and (orientation: portrait) {
            .project-modal-grid {
                grid-template-columns: repeat(3, 1fr);
                grid-template-rows: repeat(5, 1fr);
            }
        }
        .project-modal-item {
            cursor: pointer;
            font-size: calc(10px + 2vmin);
            margin: 2vmin;
            background-color: rgb(40, 40, 40);
            border: none;
            border-radius: 1em;
            position: relative;
            display: flex;
            align-items: center;
            text-align: center;
            justify-content: center;
            max-width: 100%;
            overflow: hidden;
            word-break: break-word;
            hyphens: auto;
        }
        .project-modal-item:hover {
            opacity: 0.8;
        }
        .project-modal-fill {
            border: none;
            border-radius: 1em;
            width: 100%;
            height: 100%;
            position: absolute;
            bottom: 0;
            left: 0;
        }
        .project-modal-label {
            position: relative;
            display: flex;
            z-index: 1;
            color: white;
            max-width: 90%;
            align-items: center;
            justify-content: center;
            text-align: center;
            width: 100%;
            height: 100%;
            overflow: hidden;
            word-break: break-word;
            hyphens: auto;
        }
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin-top: 30px;
            padding: 20px 0;
        }
        .pagination-button {
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .pagination-button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.15);
        }
        .pagination-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .pagination-info {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
        }
        .page-nav {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
            display: flex;
            gap: 10px;
        }
        .page-nav a {
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            border-radius: 12px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            text-decoration: none;
            cursor: pointer;
        }
        .page-nav a:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div class="page-nav">
        <a href="/" title="Track">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px;">
                <path fill-rule="evenodd" d="M3 6a3 3 0 0 1 3-3h2.25a3 3 0 0 1 3 3v2.25a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3V6Zm9.75 0a3 3 0 0 1 3-3H18a3 3 0 0 1 3 3v2.25a3 3 0 0 1-3 3h-2.25a3 3 0 0 1-3-3V6ZM3 15.75a3 3 0 0 1 3-3h2.25a3 3 0 0 1 3 3V18a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3v-2.25Zm9.75 0a3 3 0 0 1 3-3H18a3 3 0 0 1 3 3V18a3 3 0 0 1-3 3h-2.25a3 3 0 0 1-3-3v-2.25Z" clip-rule="evenodd"/>
            </svg>
        </a>
        <a href="/history" title="History">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px;">
                <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 0 1 7.5 3v1.5h9V3A.75.75 0 0 1 18 3v1.5h.75a3 3 0 0 1 3 3v11.25a3 3 0 0 1-3 3H5.25a3 3 0 0 1-3-3V7.5a3 3 0 0 1 3-3H6V3a.75.75 0 0 1 .75-.75Zm13.5 9a1.5 1.5 0 0 0-1.5-1.5H5.25a1.5 1.5 0 0 0-1.5 1.5v7.5a1.5 1.5 0 0 0 1.5 1.5h13.5a1.5 1.5 0 0 0 1.5-1.5v-7.5Z" clip-rule="evenodd"/>
            </svg>
        </a>
        <a href="/settings" title="Settings">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px;">
                <path fill-rule="evenodd" d="M12 6.75a5.25 5.25 0 0 1 6.775-5.025.75.75 0 0 1 .313 1.248l-3.32 3.319c.063.475.276.934.641 1.299.365.365.824.578 1.3.64l3.318-3.319a.75.75 0 0 1 1.248.313 5.25 5.25 0 0 1-5.472 6.756c-1.018-.086-1.87.1-2.309.634L7.344 21.3A3.298 3.298 0 1 1 2.7 16.657l8.684-7.151c.533-.44.72-1.291.634-2.309A5.342 5.342 0 0 1 12 6.75ZM4.117 19.125a.75.75 0 0 1 .75-.75h.008a.75.75 0 0 1 .75.75v.008a.75.75 0 0 1-.75.75h-.008a.75.75 0 0 1-.75-.75v-.008Z" clip-rule="evenodd"/>
            </svg>
        </a>
    </div>
    <div class="history-container">
        <div class="history-header">
            <h1>History</h1>
        </div>
        <div id="errorMessage" style="display: none;"></div>
        <div id="loadingMessage" class="loading">Loading time entries...</div>
        <div id="timeEntriesList"></div>
        <div id="pagination" style="display: none;"></div>
    </div>

    <div id="projectModal" class="project-modal">
        <button id="modalCloseBtn" class="modal-close-btn">&times;</button>
        <div id="projectModalGrid" class="project-modal-grid"></div>
    </div>

    <script>
        let projectColors = {}; // Map project name to color
        let allEntries = []; // Store all entries for pagination
        let currentPage = 1; // Current week page (1-indexed, 7 days per page)
        let allUniqueDates = []; // Sorted unique dates for pagination
        let expandedDays = new Set(); // Track which days have expanded entries
        let allProjects = []; // Full project list for modal
        let hoverPreviewElement = null; // Current hover preview element
        let isDragging = false; // Drag state
        let dragStartSlot = null; // Starting 30-min slot index
        let dragEndSlot = null; // Ending 30-min slot index
        let dragDateKey = null; // Date being dragged on
        let pendingTimeRange = null; // Time range awaiting project selection
        let pendingEntryIdForProjectChange = null; // Entry ID when changing project
        let currentTaskName = null; // For title ticker
        let currentTaskStartTime = null; // For title ticker
        const DEFAULT_TITLE = document.title;

        function getCookie(name) {
            const cname = name + "=";
            const decodedCookie = decodeURIComponent(document.cookie);
            const ca = decodedCookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(cname) === 0) {
                    return c.substring(cname.length, c.length);
                }
            }
            return "";
        }

        function getApiHeaders() {
            const apiKey = getCookie('apiToken');
            return {
                'Authorization': `Bearer ${apiKey}`,
                'X-API-Key': apiKey
            };
        }

        async function fetchProjects() {
            const apiKey = getCookie('apiToken');
            if (!apiKey) {
                return;
            }

            try {
                const response = await fetch('/api/projects', {
                    headers: getApiHeaders()
                });

                if (response.status === 401) {
                    return;
                }

                if (!response.ok) {
                    return;
                }

                const projects = await response.json();
                projectColors = {};
                projects.forEach(project => {
                    projectColors[project.name] = project.color || '#D15540';
                });
            } catch (error) {
                console.error('Error fetching projects:', error);
            }
        }

        async function getCurrentTask() {
            const apiKey = getCookie('apiToken');
            if (!apiKey) {
                currentTaskName = null;
                currentTaskStartTime = null;
                updateDocumentTitle();
                return;
            }

            try {
                const response = await fetch('/api/time-entries/current', {
                    headers: getApiHeaders()
                });

                if (!response.ok) {
                    currentTaskName = null;
                    currentTaskStartTime = null;
                    updateDocumentTitle();
                    return;
                }

                const data = await response.json();
                if (data && data.id) {
                    currentTaskName = data.name;
                    currentTaskStartTime = data.start ? new Date(data.start) : null;
                } else {
                    currentTaskName = null;
                    currentTaskStartTime = null;
                }
                updateDocumentTitle();
            } catch (error) {
                console.error('Error getting current task:', error);
                currentTaskName = null;
                currentTaskStartTime = null;
                updateDocumentTitle();
            }
        }

        function formatElapsedDuration(durationSeconds) {
            const totalSeconds = Math.max(0, Math.floor(durationSeconds));
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            const totalMinutes = Math.floor(totalSeconds / 60);
            return `${totalMinutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateDocumentTitle() {
            if (currentTaskName && currentTaskStartTime instanceof Date) {
                const elapsedSeconds = (Date.now() - currentTaskStartTime.getTime()) / 1000;
                const formattedDuration = formatElapsedDuration(elapsedSeconds);
                document.title = `${formattedDuration} ${currentTaskName}`;
                return;
            }
            document.title = DEFAULT_TITLE;
        }

        function formatDuration(seconds) {
            if (seconds < 0) return 'Running...';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hours > 0) {
                return `${hours}h ${minutes}m ${secs}s`;
            }
            return `${minutes}m ${secs}s`;
        }

        function formatDurationFromSeconds(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hours > 0) {
                return `${hours}h ${minutes}m ${secs}s`;
            }
            return `${minutes}m ${secs}s`;
        }

        function formatDateTime(dateString) {
            const date = new Date(dateString);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function formatDateWithDayOfWeek(dateString) {
            // dateString is in format "YYYY-MM-DD"
            const [year, month, day] = dateString.split('-').map(Number);
            const date = new Date(year, month - 1, day); // month is 0-indexed
            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayOfWeek = daysOfWeek[date.getDay()];
            return `${dateString} ${dayOfWeek}`;
        }

        function generateDisplayDates(uniqueDatesWithEntries) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayKey = formatDate(today.toISOString());

            if (uniqueDatesWithEntries.length === 0) return [todayKey];

            // Find the oldest entry date (last in the sorted array)
            const oldestWithData = uniqueDatesWithEntries[uniqueDatesWithEntries.length - 1];

            const allDates = [];
            let currentDate = new Date(today);
            const endDate = new Date(oldestWithData + 'T00:00:00');

            // Generate ALL dates from today back to the oldest entry date
            while (currentDate >= endDate) {
                allDates.push(formatDate(currentDate.toISOString()));
                currentDate.setDate(currentDate.getDate() - 1);
            }

            return allDates;
        }

        function formatTime(dateString) {
            const date = new Date(dateString);
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }

        function formatDateTimeForInput(dateString) {
            const date = new Date(dateString);
            // Format for datetime-local input: YYYY-MM-DDTHH:MM in LOCAL timezone
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        async function deleteTimeEntry(entryId) {
            if (!confirm('Are you sure you want to delete this time entry? This action cannot be undone.')) {
                return;
            }

            const apiKey = getCookie('apiToken');
            if (!apiKey) {
                alert('No API key found. Please go to settings and enter your API key.');
                return;
            }

            try {
                const response = await fetch(`/api/time-entries/${entryId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'X-API-Key': apiKey
                    }
                });

                if (response.status === 401) {
                    throw new Error('Invalid API key');
                }

                if (!response.ok) {
                    throw new Error(`Failed to delete time entry: ${response.status}`);
                }

                // Remove the entry from allEntries array
                allEntries = allEntries.filter(entry => entry.id !== entryId);

                // Re-render entries with updated data
                renderEntries();

            } catch (error) {
                console.error('Error deleting time entry:', error);
                alert(`Error deleting time entry: ${error.message}`);
            }
        }

        function editTimeEntry(entryId) {
            const entryElement = document.querySelector(`[data-entry-id="${entryId}"]`);
            if (entryElement) {
                entryElement.classList.add('edit-mode');
            }
        }

        function cancelEdit(entryId) {
            const entryElement = document.querySelector(`[data-entry-id="${entryId}"]`);
            if (entryElement) {
                entryElement.classList.remove('edit-mode');
            }
        }

        async function saveTimeEntry(entryId) {
            const entryElement = document.querySelector(`[data-entry-id="${entryId}"]`);
            if (!entryElement) return;

            const startInput = entryElement.querySelector('.start-input');
            const endInput = entryElement.querySelector('.end-input');

            const startTime = startInput.value;
            const endTime = endInput.value;

            if (!startTime) {
                alert('Start time is required');
                return;
            }

            const apiKey = getCookie('apiToken');
            if (!apiKey) {
                alert('No API key found. Please go to settings and enter your API key.');
                return;
            }

            try {
                // Find the current entry to get original values
                const currentEntry = allEntries.find(entry => entry.id === entryId);
                if (!currentEntry) {
                    throw new Error('Entry not found');
                }

                const originalStartTime = new Date(currentEntry.start).toISOString();
                const originalEndTime = currentEntry.stop ? new Date(currentEntry.stop).toISOString() : null;
                const newStartTimeISO = new Date(startTime).toISOString();
                const newEndTimeISO = endTime ? new Date(endTime).toISOString() : null;

                // Check if start time or end time changed
                const startTimeChanged = originalStartTime !== newStartTimeISO;
                const endTimeChanged = originalEndTime !== newEndTimeISO;

                // Sort all entries chronologically (oldest first) to find previous/next entries
                const entriesChronological = [...allEntries].sort((a, b) => {
                    return new Date(a.start) - new Date(b.start);
                });

                const currentIndex = entriesChronological.findIndex(entry => entry.id === entryId);
                const previousEntry = currentIndex > 0 ? entriesChronological[currentIndex - 1] : null;
                const nextEntry = currentIndex < entriesChronological.length - 1 ? entriesChronological[currentIndex + 1] : null;

                // Update the current entry
                const response = await fetch(`/api/time-entries/${entryId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`,
                        'X-API-Key': apiKey
                    },
                    body: JSON.stringify({
                        start_time: newStartTimeISO,
                        end_time: newEndTimeISO
                    })
                });

                if (response.status === 401) {
                    throw new Error('Invalid API key');
                }

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `Failed to update time entry: ${response.status}`);
                }

                // If start time changed, update previous entry's end time
                if (startTimeChanged && previousEntry && previousEntry.stop) {
                    try {
                        const prevResponse = await fetch(`/api/time-entries/${previousEntry.id}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`,
                                'X-API-Key': apiKey
                            },
                            body: JSON.stringify({
                                end_time: newStartTimeISO
                            })
                        });

                        if (!prevResponse.ok) {
                            console.error('Failed to update previous entry end time');
                        }
                    } catch (error) {
                        console.error('Error updating previous entry end time:', error);
                    }
                }

                // If end time changed, update next entry's start time
                if (endTimeChanged && newEndTimeISO && nextEntry) {
                    try {
                        const nextResponse = await fetch(`/api/time-entries/${nextEntry.id}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`,
                                'X-API-Key': apiKey
                            },
                            body: JSON.stringify({
                                start_time: newEndTimeISO
                            })
                        });

                        if (!nextResponse.ok) {
                            console.error('Failed to update next entry start time');
                        }
                    } catch (error) {
                        console.error('Error updating next entry start time:', error);
                    }
                }

                // Reload the page to refresh all data
                loadTimeEntries();

            } catch (error) {
                console.error('Error updating time entry:', error);
                alert(`Error updating time entry: ${error.message}`);
            }
        }

        async function loadTimeEntries(preservePage = false) {
            const apiKey = getCookie('apiToken');
            if (!apiKey) {
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('errorMessage').style.display = 'block';
                document.getElementById('errorMessage').textContent = 'No API key found. Please go to settings and enter your API key.';
                document.getElementById('errorMessage').className = 'error';
                return;
            }

            // Save current page if we want to preserve it
            const savedPage = preservePage ? currentPage : null;

            try {
                const response = await fetch('/api/time-entries?all=true', {
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'X-API-Key': apiKey
                    }
                });

                if (response.status === 401) {
                    throw new Error('Invalid API key');
                }

                if (!response.ok) {
                    throw new Error(`Failed to load time entries: ${response.status}`);
                }

                const entries = await response.json();
                document.getElementById('loadingMessage').style.display = 'none';

                // Store all entries for pagination (may be empty)
                allEntries = entries;

                // Calculate unique dates with entries (sorted descending, most recent first)
                const datesSet = new Set();
                allEntries.forEach(entry => {
                    datesSet.add(formatDate(entry.start));
                });
                const uniqueDatesWithEntries = Array.from(datesSet).sort((a, b) => {
                    return new Date(b) - new Date(a);
                });

                // Generate display dates including empty days between today and most recent entry
                allUniqueDates = generateDisplayDates(uniqueDatesWithEntries);
                
                // Restore page if preserving, otherwise reset to first page
                if (preservePage && savedPage !== null) {
                    const daysPerPage = 7;
                    const totalPages = Math.ceil(allUniqueDates.length / daysPerPage);
                    currentPage = Math.min(savedPage, totalPages); // Ensure page is valid
                    if (currentPage < 1) currentPage = 1;
                } else {
                    currentPage = 1; // Reset to first page when reloading
                }

                renderEntries();
            } catch (error) {
                console.error('Error loading time entries:', error);
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('errorMessage').style.display = 'block';
                document.getElementById('errorMessage').textContent = error.message;
                document.getElementById('errorMessage').className = 'error';
            }
        }

        function renderUntrackedTimeEntry(gapStartTime, gapEndTime, previousEntryId, nextEntryId) {
            const startTime = formatTime(gapStartTime);
            const endTime = formatTime(gapEndTime);
            const durationSeconds = Math.floor((new Date(gapEndTime) - new Date(gapStartTime)) / 1000);
            const duration = formatDurationFromSeconds(durationSeconds);
            const durationHours = durationSeconds / 3600;
            const widthPercentage = Math.min((durationHours / 2) * 100, 100);
            const untrackedColor = '#666666';
            const projectNameStyle = `background-color: ${untrackedColor};`;

            return `
                <div class="time-entry" style="--visualization-color: ${untrackedColor}; --visualization-width: ${widthPercentage}%; opacity: 0.7;" data-gap-start="${gapStartTime}" data-gap-end="${gapEndTime}" data-previous-entry-id="${previousEntryId}" data-next-entry-id="${nextEntryId}">
                    <div class="time-entry-header">
                        <span class="project-name project-name-colored" style="${projectNameStyle}">Untracked Time</span>
                        <div>
                            <span class="duration">${duration}</span>
                            <button class="extend-button" onclick="extendAbove(${previousEntryId}, ${nextEntryId}, '${gapStartTime}')">Extend Above</button>
                            <button class="extend-button" onclick="extendBelow(${previousEntryId}, ${nextEntryId}, '${gapEndTime}')">Extend Below</button>
                        </div>
                    </div>
                    <div class="time-range">
                        ${startTime}
                    </div>
                </div>
            `;
        }

        function renderTransitionTime(prevEndTime, nextStartTime) {
            const prevTime = formatTime(prevEndTime);
            const nextTime = formatTime(nextStartTime);
            return `
                <div class="time-range" style="text-align: center; padding: 8px 0; color: rgba(255, 255, 255, 0.6); font-size: 0.9em;">
                    ${nextTime}
                </div>
            `;
        }

        function renderDayMinimap(dateKey, items, allEntriesForMinimap) {
            // Calculate start and end of day (midnight to midnight)
            const dayStart = new Date(dateKey + 'T00:00:00');
            // Use exactly midnight of next day as the cutoff point
            const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);
            const dayDuration = dayEnd.getTime() - dayStart.getTime();
            
            // Collect all entries that overlap with this day (including from previous days)
            const overlappingEntries = [];
            
            // First, add entries from the items passed in (current day's items)
            items.forEach(item => {
                if (item.type === 'entry') {
                    overlappingEntries.push(item.entry);
                }
            });
            
            // Then, check all entries to find ones from previous days that bleed into this day
            if (allEntriesForMinimap) {
                allEntriesForMinimap.forEach(entry => {
                    const entryStart = new Date(entry.start);
                    const entryEnd = entry.stop && entry.duration >= 0 
                        ? new Date(entry.stop) 
                        : new Date(); // Use current time for running entries
                    
                    // Check if entry overlaps with this day
                    // Entry overlaps if it starts before dayEnd and ends after dayStart
                    if (entryStart.getTime() < dayEnd.getTime() && entryEnd.getTime() > dayStart.getTime()) {
                        // Only add if not already in the list (avoid duplicates)
                        if (!overlappingEntries.find(e => e.id === entry.id)) {
                            overlappingEntries.push(entry);
                        }
                    }
                });
            }
            
            // Sort entries chronologically (oldest first) for the minimap
            overlappingEntries.sort((a, b) => {
                return new Date(a.start).getTime() - new Date(b.start).getTime();
            });
            
            let segments = [];
            
            overlappingEntries.forEach(entry => {
                let startTime = new Date(entry.start);
                let endTime = entry.stop && entry.duration >= 0 
                    ? new Date(entry.stop) 
                    : new Date(); // Use current time for running entries
                
                // Clamp times to day boundaries (entries bleeding from previous day start at 0%, 
                // entries extending past midnight are cut off at 100%)
                const visibleStart = Math.max(startTime.getTime(), dayStart.getTime());
                const visibleEnd = Math.min(endTime.getTime(), dayEnd.getTime());
                
                // Only show if there's overlap with this day
                if (visibleStart < visibleEnd) {
                    const leftPercent = ((visibleStart - dayStart.getTime()) / dayDuration) * 100;
                    const widthPercent = ((visibleEnd - visibleStart) / dayDuration) * 100;
                    
                    // Get project color
                    const projectName = entry.name || 'Unknown Project';
                    const projectColor = projectColors[projectName] || '#D15540';
                    
                    if (widthPercent > 0 && leftPercent < 100) {
                        segments.push({
                            left: Math.max(0, leftPercent),
                            width: Math.min(100 - leftPercent, widthPercent),
                            color: projectColor,
                            type: 'entry'
                        });
                    }
                }
            });
            
            // Also handle gaps from the items array
            items.forEach(item => {
                if (item.type === 'gap') {
                    const gapStart = new Date(item.gapStart);
                    const gapEnd = new Date(item.gapEnd);
                    
                    // Clamp gap to day boundaries
                    const visibleStart = Math.max(gapStart.getTime(), dayStart.getTime());
                    const visibleEnd = Math.min(gapEnd.getTime(), dayEnd.getTime());
                    
                    // Only show if there's overlap with this day
                    if (visibleStart < visibleEnd) {
                        const leftPercent = ((visibleStart - dayStart.getTime()) / dayDuration) * 100;
                        const widthPercent = ((visibleEnd - visibleStart) / dayDuration) * 100;
                        
                        if (widthPercent > 0 && leftPercent < 100) {
                            segments.push({
                                left: Math.max(0, leftPercent),
                                width: Math.min(100 - leftPercent, widthPercent),
                                color: 'rgba(102, 102, 102, 0.3)',
                                type: 'gap',
                                gapStart: new Date(visibleStart).toISOString(),
                                gapEnd: new Date(visibleEnd).toISOString()
                            });
                        }
                    }
                }
            });
            
            // Generate HTML for segments
            let segmentsHtml = '';
            segments.forEach(segment => {
                const gapAttrs = segment.type === 'gap' ? `data-gap-start="${segment.gapStart}" data-gap-end="${segment.gapEnd}"` : '';
                segmentsHtml += `<div class="minimap-segment ${segment.type === 'gap' ? 'untracked' : ''}" ${gapAttrs} style="left: ${segment.left}%; width: ${segment.width}%; background-color: ${segment.color};"></div>`;
            });
            
            return `<div class="day-minimap" data-date-key="${dateKey}">${segmentsHtml}</div>`;
        }

        function renderEmptyDayMinimap(dateKey, bleedingEntries) {
            // Render bleeding entries from previous days
            let segmentsHtml = '';
            if (bleedingEntries && bleedingEntries.length > 0) {
                const dayStart = new Date(dateKey + 'T00:00:00');
                const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);
                const dayDuration = dayEnd.getTime() - dayStart.getTime();

                bleedingEntries.forEach(entry => {
                    const entryStart = new Date(entry.start);
                    const entryEnd = entry.stop && entry.duration >= 0
                        ? new Date(entry.stop)
                        : new Date();

                    const visibleStart = Math.max(entryStart.getTime(), dayStart.getTime());
                    const visibleEnd = Math.min(entryEnd.getTime(), dayEnd.getTime());

                    if (visibleStart < visibleEnd) {
                        const leftPercent = ((visibleStart - dayStart.getTime()) / dayDuration) * 100;
                        const widthPercent = ((visibleEnd - visibleStart) / dayDuration) * 100;
                        const projectName = entry.name || 'Unknown Project';
                        const projectColor = projectColors[projectName] || '#D15540';

                        segmentsHtml += `<div class="minimap-segment" style="left: ${leftPercent}%; width: ${widthPercent}%; background-color: ${projectColor};"></div>`;
                    }
                });
            }

            return `
                <div class="day-minimap day-minimap-empty"
                     data-date-key="${dateKey}"
                     data-empty="true">${segmentsHtml}</div>
            `;
        }

        function renderTimeEntry(entry) {
            const isRunning = !entry.stop || entry.duration < 0;
            
            let duration, durationHours, widthPercentage;
            if (isRunning) {
                // Calculate current duration for running entry
                const now = new Date();
                const start = new Date(entry.start);
                const currentDurationSeconds = Math.floor((now - start) / 1000);
                durationHours = currentDurationSeconds / 3600;
                widthPercentage = Math.min((durationHours / 2) * 100, 100);
                duration = formatDurationFromSeconds(currentDurationSeconds);
            } else {
                endTime = formatTime(entry.stop);
                duration = formatDuration(entry.duration);
                durationHours = entry.duration / 3600;
                widthPercentage = Math.min((durationHours / 2) * 100, 100);
            }
            
            const projectName = entry.name || 'Unknown Project';
            const projectColor = projectColors[projectName] || '#D15540';
            const projectNameStyle = `background-color: ${projectColor};`;
            const runningAttr = isRunning ? `data-running="true" data-start-time="${entry.start}"` : '';
            const startTime = formatTime(entry.start);

            const splitDisabled = isRunning ? 'disabled' : '';

            return `
                <div class="time-entry" data-entry-id="${entry.id}" ${runningAttr} style="--visualization-color: ${projectColor}; --visualization-width: ${widthPercentage}%;">
                    <div class="time-entry-header">
                        <span class="project-name project-name-colored" style="${projectNameStyle}; cursor: pointer;" onclick="changeEntryProject(${entry.id})">${projectName}</span>
                        <div>
                            <span class="duration">${duration}</span>
                            <button class="edit-button" onclick="editTimeEntry(${entry.id})" title="Edit">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M21.731 2.269a2.625 2.625 0 0 0-3.712 0l-1.157 1.157 3.712 3.712 1.157-1.157a2.625 2.625 0 0 0 0-3.712ZM19.513 8.199l-3.712-3.712-8.4 8.4a5.25 5.25 0 0 0-1.32 2.214l-.8 2.685a.75.75 0 0 0 .933.933l2.685-.8a5.25 5.25 0 0 0 2.214-1.32l8.4-8.4Z" />
                                    <path d="M5.25 5.25a3 3 0 0 0-3 3v10.5a3 3 0 0 0 3 3h10.5a3 3 0 0 0 3-3V13.5a.75.75 0 0 0-1.5 0v5.25a1.5 1.5 0 0 1-1.5 1.5H5.25a1.5 1.5 0 0 1-1.5-1.5V8.25a1.5 1.5 0 0 1 1.5-1.5h5.25a.75.75 0 0 0 0-1.5H5.25Z" />
                                </svg>
                            </button>
                            <button class="split-button" onclick="splitTimeEntry(${entry.id})" title="Split" ${splitDisabled}>
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                    <path fill-rule="evenodd" d="M11.47 2.47a.75.75 0 0 1 1.06 0l3.75 3.75a.75.75 0 0 1-1.06 1.06l-2.47-2.47V12h4.5a.75.75 0 0 1 0 1.5h-4.5v6.19l2.47-2.47a.75.75 0 1 1 1.06 1.06l-3.75 3.75a.75.75 0 0 1-1.06 0l-3.75-3.75a.75.75 0 1 1 1.06-1.06l2.47 2.47V13.5h-4.5a.75.75 0 0 1 0-1.5h4.5V4.81L8.78 7.28a.75.75 0 0 1-1.06-1.06l3.75-3.75Z" clip-rule="evenodd" />
                                </svg>
                            </button>
                            <button class="delete-button" onclick="deleteTimeEntry(${entry.id})" title="Delete">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                    <path fill-rule="evenodd" d="M16.5 4.478v.227a48.816 48.816 0 0 1 3.878.512.75.75 0 1 1-.256 1.478l-.209-.035-1.005 13.07a3 3 0 0 1-2.991 2.77H8.084a3 3 0 0 1-2.991-2.77L4.087 6.66l-.209.035a.75.75 0 0 1-.256-1.478A48.567 48.567 0 0 1 7.5 4.705v-.227c0-1.564 1.213-2.9 2.816-2.951a52.662 52.662 0 0 1 3.369 0c1.603.051 2.815 1.387 2.815 2.951Zm-6.136-1.452a51.196 51.196 0 0 1 3.273 0C14.39 3.05 15 3.684 15 4.478v.113a49.488 49.488 0 0 0-6 0v-.113c0-.794.609-1.428 1.364-1.452Zm-.355 5.945a.75.75 0 1 0-1.5.058l.347 9a.75.75 0 1 0 1.499-.058l-.346-9Zm5.48.058a.75.75 0 1 0-1.498-.058l-.347 9a.75.75 0 0 0 1.5.058l.345-9Z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="edit-form">
                        <input type="datetime-local" class="edit-input start-input" value="${formatDateTimeForInput(entry.start)}" placeholder="Start time">
                        <input type="datetime-local" class="edit-input end-input" value="${entry.stop ? formatDateTimeForInput(entry.stop) : ''}" placeholder="End time (leave empty if running)">
                        <button class="save-button" onclick="saveTimeEntry(${entry.id})">Save</button>
                        <button class="cancel-button" onclick="cancelEdit(${entry.id})">Cancel</button>
                    </div>
                    <div class="time-range">
                        ${startTime}
                    </div>
                </div>
            `;
        }

        function renderEntries() {
            if (allUniqueDates.length === 0) {
                document.getElementById('timeEntriesList').innerHTML = '<div class="loading">No time entries found.</div>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }

            // Calculate total pages based on 7 days per page
            const daysPerPage = 7;
            const totalPages = Math.ceil(allUniqueDates.length / daysPerPage);
            
            // Validate current page
            if (currentPage < 1) currentPage = 1;
            if (currentPage > totalPages) currentPage = totalPages;
            
            // Get the dates for the current page
            const startIndex = (currentPage - 1) * daysPerPage;
            const endIndex = Math.min(startIndex + daysPerPage, allUniqueDates.length);
            const currentPageDates = allUniqueDates.slice(startIndex, endIndex);

            // Automatically expand today's date if it's on the current page
            const today = new Date();
            const todayDateKey = formatDate(today.toISOString());
            if (currentPageDates.includes(todayDateKey)) {
                expandedDays.add(todayDateKey);
            }

            // Group ALL entries by date (we need all entries to handle bleeding from other days)
            const entriesByDate = {};
            allEntries.forEach(entry => {
                const dateKey = formatDate(entry.start);
                if (!entriesByDate[dateKey]) {
                    entriesByDate[dateKey] = [];
                }
                entriesByDate[dateKey].push(entry);
            });

            // Sort entries within each date by start time (descending, most recent first)
            Object.keys(entriesByDate).forEach(dateKey => {
                entriesByDate[dateKey].sort((a, b) => {
                    return new Date(b.start) - new Date(a.start);
                });
            });
            
            // Build HTML for all days on the current page
            let entriesHtml = '';
            
            // Loop through each date on the current page (most recent first)
            currentPageDates.forEach(dateKey => {
                const currentDayEntries = entriesByDate[dateKey] || [];

                // Build HTML with date headers
                // First, process ALL entries chronologically (oldest first) to detect gaps globally
                // Then group items by date for display
                let allItems = []; // Array of {type: 'entry'|'gap', entry?, gapStart?, gapEnd?, dateKey}
                let previousEntryEndTime = null;
                
                // Get all entries in chronological order (oldest first) for gap detection
                // Only process entries for the current day
                const allEntriesChronological = [...currentDayEntries].sort((a, b) => {
                    return new Date(a.start) - new Date(b.start);
                });
                
                // Process entries chronologically to detect gaps
                let previousEntry = null;
                allEntriesChronological.forEach(entry => {
                    const entryDateKey = formatDate(entry.start);
                    
                    // Check if there's a gap between this entry and the previous one
                    if (previousEntryEndTime !== null && previousEntry !== null) {
                        // Only check if we have a previous entry end time
                        const entryStartTime = new Date(entry.start);
                        const prevEndTime = new Date(previousEntryEndTime);
                        
                        // Check if times don't match (allowing for small rounding differences)
                        if (Math.abs(entryStartTime.getTime() - prevEndTime.getTime()) > 1000) {
                            // There's a gap - add untracked time entry
                            const gapDateKey = formatDate(previousEntryEndTime);
                            allItems.push({ 
                                type: 'gap', 
                                gapStart: previousEntryEndTime, 
                                gapEnd: entry.start, 
                                dateKey: gapDateKey,
                                previousEntryId: previousEntry.id,
                                nextEntryId: entry.id
                            });
                        }
                    }
                    
                    // Add the actual entry
                    allItems.push({ type: 'entry', entry, dateKey: entryDateKey });
                    
                    // Update previous entry end time and entry for next iteration
                    // Only update if this entry has an end time (not running)
                    if (entry.stop && entry.duration >= 0) {
                        previousEntryEndTime = entry.stop;
                        previousEntry = entry;
                    } else {
                        // Running entry - can't determine end time, so set to null
                        // This means we won't check gaps for the next entry after a running entry
                        previousEntryEndTime = null;
                        previousEntry = null;
                    }
                });
                
                // Now group items by date for display
                const itemsByDate = {};
                allItems.forEach(item => {
                    const itemDateKey = item.dateKey;
                    if (!itemsByDate[itemDateKey]) {
                        itemsByDate[itemDateKey] = [];
                    }
                    itemsByDate[itemDateKey].push(item);
                });
                
                // Build HTML for this day
                if (itemsByDate[dateKey] && itemsByDate[dateKey].length > 0) {
                    // Add date header with day of the week
                    entriesHtml += `<div class="date-header">${formatDateWithDayOfWeek(dateKey)}</div>`;
                    
                    // Add minimap visualization (pass all entries to find overlapping entries from other days)
                    entriesHtml += renderDayMinimap(dateKey, itemsByDate[dateKey], allEntries);
                    
                    // Start day entries container
                    const isExpanded = expandedDays.has(dateKey);
                    entriesHtml += `<div class="day-entries ${isExpanded ? 'expanded' : ''}" data-date-key="${dateKey}">`;
                    
                    // Process items in forward chronological order to build transitions
                    // Then reverse for display (most recent first)
                    const forwardItems = itemsByDate[dateKey];
                    const itemsWithTransitions = [];
                    let nextEntryStartTime = null;
                    
                    // Process items in forward order (oldest first) to determine transitions
                    forwardItems.forEach((item, index) => {
                        if (item.type === 'gap') {
                            itemsWithTransitions.push({ ...item, transitionBefore: null });
                            nextEntryStartTime = item.gapEnd;
                        } else if (item.type === 'entry') {
                            // Add transition time if we have a next entry start time
                            const transitionBefore = nextEntryStartTime !== null 
                                ? { prevEnd: nextEntryStartTime, nextStart: item.entry.start }
                                : null;
                            itemsWithTransitions.push({ ...item, transitionBefore });
                            
                            // Update nextEntryStartTime to this entry's end time (if it has one)
                            if (item.entry.stop && item.entry.duration >= 0) {
                                nextEntryStartTime = item.entry.stop;
                            } else {
                                // Running entry - can't determine end time
                                nextEntryStartTime = null;
                            }
                        }
                    });
                    
                    // Reverse for display (most recent first)
                    itemsWithTransitions.reverse().forEach((item) => {
                        if (item.type === 'gap') {
                            entriesHtml += renderUntrackedTimeEntry(item.gapStart, item.gapEnd, item.previousEntryId, item.nextEntryId);
                        } else if (item.type === 'entry') {
                            entriesHtml += renderTimeEntry(item.entry);
                        }
                    });
                    
                    // Close day entries container
                    entriesHtml += `</div>`;
                } else {
                    // No entries starting on this day - check for bleeding entries from previous days
                    const dayStart = new Date(dateKey + 'T00:00:00');
                    const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);

                    const bleedingEntries = allEntries.filter(entry => {
                        const entryStart = new Date(entry.start);
                        const entryEnd = entry.stop && entry.duration >= 0
                            ? new Date(entry.stop)
                            : new Date();
                        // Entry started before this day but ends during or after this day starts
                        return entryStart < dayStart && entryEnd > dayStart;
                    });

                    entriesHtml += `<div class="date-header">${formatDateWithDayOfWeek(dateKey)}</div>`;
                    entriesHtml += renderEmptyDayMinimap(dateKey, bleedingEntries);
                }
            });

            document.getElementById('timeEntriesList').innerHTML = entriesHtml;

            // Attach event listeners for empty day interactions
            attachEmptyDayListeners();

            // Render pagination controls if there are more than 1 page
            if (totalPages > 1) {
                const firstDate = currentPageDates[currentPageDates.length - 1]; // Oldest date on page
                const lastDate = currentPageDates[0]; // Most recent date on page
                const dateRange = currentPageDates.length === 1 
                    ? firstDate 
                    : `${firstDate} - ${lastDate}`;
                
                const paginationHtml = `
                    <div class="pagination">
                        <button class="pagination-button" onclick="goToPage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>Previous Week</button>
                        <span class="pagination-info">${dateRange} (Week ${currentPage} of ${totalPages})</span>
                        <button class="pagination-button" onclick="goToPage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>Next Week</button>
                    </div>
                `;
                document.getElementById('pagination').innerHTML = paginationHtml;
                document.getElementById('pagination').style.display = 'flex';
            } else {
                document.getElementById('pagination').style.display = 'none';
            }
            
            // Update running entries immediately and set up interval
            updateRunningEntries();
        }

        function updateRunningEntries() {
            const runningEntries = document.querySelectorAll('.time-entry[data-running="true"]');
            runningEntries.forEach(entryElement => {
                const startTimeStr = entryElement.getAttribute('data-start-time');
                if (!startTimeStr) return;
                
                const start = new Date(startTimeStr);
                const now = new Date();
                const currentDurationSeconds = Math.floor((now - start) / 1000);
                const durationHours = currentDurationSeconds / 3600;
                const widthPercentage = Math.min((durationHours / 2) * 100, 100);
                
                // Update duration display
                const durationElement = entryElement.querySelector('.duration');
                if (durationElement) {
                    durationElement.textContent = formatDurationFromSeconds(currentDurationSeconds);
                }
                
                // Update visualization width
                entryElement.style.setProperty('--visualization-width', `${widthPercentage}%`);
            });
        }

        function goToPage(page) {
            const daysPerPage = 7;
            const totalPages = Math.ceil(allUniqueDates.length / daysPerPage);
            if (page >= 1 && page <= totalPages) {
                currentPage = page;
                renderEntries();
                // Scroll to top of entries list
                document.getElementById('timeEntriesList').scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function toggleDayEntries(dateKey) {
            const entriesContainer = document.querySelector(`.day-entries[data-date-key="${dateKey}"]`);
            if (entriesContainer) {
                if (expandedDays.has(dateKey)) {
                    expandedDays.delete(dateKey);
                    entriesContainer.classList.remove('expanded');
                } else {
                    expandedDays.add(dateKey);
                    entriesContainer.classList.add('expanded');
                }
            }
        }

        async function extendAbove(previousEntryId, nextEntryId, gapStartTime) {
            // Extend the entry below (next entry) to start at gapStartTime (previous entry's end time)
            const apiKey = getCookie('apiToken');
            if (!apiKey) {
                alert('No API key found. Please go to settings and enter your API key.');
                return;
            }

            try {
                const response = await fetch(`/api/time-entries/${nextEntryId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`,
                        'X-API-Key': apiKey
                    },
                    body: JSON.stringify({
                        start_time: gapStartTime
                    })
                });

                if (response.status === 401) {
                    throw new Error('Invalid API key');
                }

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `Failed to update time entry: ${response.status}`);
                }

                // Reload entries to show updated times, preserving current page
                await loadTimeEntries(true);
            } catch (error) {
                console.error('Error extending above:', error);
                alert(`Error extending above: ${error.message}`);
            }
        }

        async function extendBelow(previousEntryId, nextEntryId, gapEndTime) {
            // Extend the entry above (previous entry) to end at gapEndTime (next entry's start time)
            const apiKey = getCookie('apiToken');
            if (!apiKey) {
                alert('No API key found. Please go to settings and enter your API key.');
                return;
            }

            try {
                const response = await fetch(`/api/time-entries/${previousEntryId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`,
                        'X-API-Key': apiKey
                    },
                    body: JSON.stringify({
                        end_time: gapEndTime
                    })
                });

                if (response.status === 401) {
                    throw new Error('Invalid API key');
                }

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `Failed to update time entry: ${response.status}`);
                }

                // Reload entries to show updated times, preserving current page
                await loadTimeEntries(true);
            } catch (error) {
                console.error('Error extending below:', error);
                alert(`Error extending below: ${error.message}`);
            }
        }

        // Track if we're in add-entry mode vs click-to-expand mode
        let timeIndicatorStart = null;
        let timeIndicatorEnd = null;

        // Minimap interaction handlers - work on ALL minimaps
        function attachEmptyDayListeners() {
            // Attach to ALL minimaps, not just empty ones
            const allMinimaps = document.querySelectorAll('.day-minimap');
            allMinimaps.forEach(minimap => {
                // Remove old onclick if present
                minimap.removeAttribute('onclick');
                minimap.addEventListener('mousemove', handleMinimapMouseMove);
                minimap.addEventListener('mouseleave', handleMinimapMouseLeave);
                minimap.addEventListener('mousedown', handleMinimapMouseDown);
            });

            // Global listeners for drag
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
        }

        function getSlotFromMousePosition(minimap, mouseX) {
            const rect = minimap.getBoundingClientRect();
            const relativeX = mouseX - rect.left;
            const percentage = Math.max(0, Math.min(1, relativeX / rect.width));
            // 48 slots of 30 minutes each
            return Math.floor(percentage * 48);
        }

        function slotToTimeString(slot) {
            const hours = Math.floor(slot / 2);
            const minutes = (slot % 2) * 30;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function getClickedSegment(minimap, mouseX) {
            const rect = minimap.getBoundingClientRect();
            const relativeX = mouseX - rect.left;
            const percentage = (relativeX / rect.width) * 100;

            const segments = minimap.querySelectorAll('.minimap-segment');
            for (const segment of segments) {
                const left = parseFloat(segment.style.left);
                const width = parseFloat(segment.style.width);
                if (percentage >= left && percentage <= left + width) {
                    return segment;
                }
            }
            return null;
        }

        function isClickOnSegment(minimap, mouseX) {
            return getClickedSegment(minimap, mouseX) !== null;
        }

        function handleMinimapMouseMove(e) {
            if (isDragging) return;

            const minimap = e.currentTarget;
            const slot = getSlotFromMousePosition(minimap, e.clientX);

            // Check if hovering over an entry segment (not a gap)
            const hoveredSegment = getClickedSegment(minimap, e.clientX);
            if (hoveredSegment && !hoveredSegment.classList.contains('untracked')) {
                // Hovering over an entry segment - show pointer
                if (hoverPreviewElement && hoverPreviewElement.parentNode === minimap) {
                    minimap.removeChild(hoverPreviewElement);
                    hoverPreviewElement = null;
                }
                removeTimeIndicators(minimap);
                minimap.style.cursor = 'pointer';
                return;
            }
            // Hovering over empty space or a gap - show crosshair and hover preview

            minimap.style.cursor = 'crosshair';

            // Remove existing preview
            if (hoverPreviewElement && hoverPreviewElement.parentNode === minimap) {
                minimap.removeChild(hoverPreviewElement);
            }

            // Create new preview for one slot (30 min)
            hoverPreviewElement = document.createElement('div');
            hoverPreviewElement.className = 'hover-preview';
            const slotWidth = 100 / 48;
            hoverPreviewElement.style.left = `${slot * slotWidth}%`;
            hoverPreviewElement.style.width = `${slotWidth}%`;
            minimap.appendChild(hoverPreviewElement);

            // Show time indicators at edges of selection
            updateTimeIndicators(minimap, slot, slot);
        }

        function handleMinimapMouseLeave(e) {
            if (isDragging) return;

            const minimap = e.currentTarget;

            // Remove hover preview
            if (hoverPreviewElement && hoverPreviewElement.parentNode === minimap) {
                minimap.removeChild(hoverPreviewElement);
                hoverPreviewElement = null;
            }

            // Remove time indicators
            removeTimeIndicators(minimap);
        }

        function handleMinimapMouseDown(e) {
            const minimap = e.currentTarget;
            const dateKey = minimap.getAttribute('data-date-key');

            // Check if clicking on a segment (but not a gap - gaps allow adding entries)
            const clickedSegment = getClickedSegment(minimap, e.clientX);
            if (clickedSegment && !clickedSegment.classList.contains('untracked')) {
                // Clicking on an entry segment toggles expand
                toggleDayEntries(dateKey);
                return;
            }

            // Otherwise, start drag to add entry
            e.preventDefault();
            const slot = getSlotFromMousePosition(minimap, e.clientX);

            isDragging = true;
            dragStartSlot = slot;
            dragEndSlot = slot;
            dragDateKey = dateKey;

            // Remove hover preview, create drag selection
            if (hoverPreviewElement && hoverPreviewElement.parentNode === minimap) {
                minimap.removeChild(hoverPreviewElement);
                hoverPreviewElement = null;
            }

            updateSelectionVisual(minimap);
        }

        function handleDragMove(e) {
            if (!isDragging || !dragDateKey) return;

            const minimap = document.querySelector(`.day-minimap[data-date-key="${dragDateKey}"]`);
            if (!minimap) return;

            const slot = getSlotFromMousePosition(minimap, e.clientX);
            dragEndSlot = Math.max(0, Math.min(47, slot));
            updateSelectionVisual(minimap);
        }

        function handleDragEnd(e) {
            if (!isDragging || !dragDateKey) return;

            const minimap = document.querySelector(`.day-minimap[data-date-key="${dragDateKey}"]`);

            // Calculate time range
            const startSlot = Math.min(dragStartSlot, dragEndSlot);
            const endSlot = Math.max(dragStartSlot, dragEndSlot) + 1; // +1 because end is exclusive

            const dateKey = dragDateKey;

            // Reset drag state
            isDragging = false;
            dragStartSlot = null;
            dragEndSlot = null;
            dragDateKey = null;

            // Remove selection visual and time indicators
            if (minimap) {
                const selection = minimap.querySelector('.drag-selection');
                if (selection) {
                    minimap.removeChild(selection);
                }
                removeTimeIndicators(minimap);
            }

            // Calculate actual times
            const [year, month, day] = dateKey.split('-').map(Number);
            const startDate = new Date(year, month - 1, day);
            startDate.setMinutes(startSlot * 30);
            const endDate = new Date(year, month - 1, day);
            endDate.setMinutes(endSlot * 30);

            pendingTimeRange = {
                startTime: startDate.toISOString(),
                endTime: endDate.toISOString(),
                dateKey: dateKey
            };

            showProjectModal();
        }

        function removeTimeIndicators(minimap) {
            if (timeIndicatorStart && timeIndicatorStart.parentNode === minimap) {
                minimap.removeChild(timeIndicatorStart);
                timeIndicatorStart = null;
            }
            if (timeIndicatorEnd && timeIndicatorEnd.parentNode === minimap) {
                minimap.removeChild(timeIndicatorEnd);
                timeIndicatorEnd = null;
            }
        }

        function updateTimeIndicators(minimap, startSlot, endSlot) {
            const slotWidth = 100 / 48;
            const actualStart = Math.min(startSlot, endSlot);
            const actualEnd = Math.max(startSlot, endSlot);

            // Remove existing indicators
            removeTimeIndicators(minimap);

            // Create start time indicator (right-aligned on left edge)
            timeIndicatorStart = document.createElement('div');
            timeIndicatorStart.className = 'time-indicator-start';
            timeIndicatorStart.textContent = slotToTimeString(actualStart);
            timeIndicatorStart.style.left = `${actualStart * slotWidth}%`;
            minimap.appendChild(timeIndicatorStart);

            // Create end time indicator (left-aligned on right edge)
            timeIndicatorEnd = document.createElement('div');
            timeIndicatorEnd.className = 'time-indicator-end';
            timeIndicatorEnd.textContent = slotToTimeString(actualEnd + 1);
            timeIndicatorEnd.style.left = `${(actualEnd + 1) * slotWidth}%`;
            minimap.appendChild(timeIndicatorEnd);
        }

        function updateSelectionVisual(minimap) {
            // Remove existing selection
            const existingSelection = minimap.querySelector('.drag-selection');
            if (existingSelection) {
                minimap.removeChild(existingSelection);
            }

            // Create selection element
            const selection = document.createElement('div');
            selection.className = 'drag-selection';
            const slotWidth = 100 / 48;
            const startSlot = Math.min(dragStartSlot, dragEndSlot);
            const endSlot = Math.max(dragStartSlot, dragEndSlot);
            const width = (endSlot - startSlot + 1) * slotWidth;
            selection.style.left = `${startSlot * slotWidth}%`;
            selection.style.width = `${width}%`;
            minimap.appendChild(selection);

            // Update time indicators at edges
            updateTimeIndicators(minimap, dragStartSlot, dragEndSlot);
        }

        function showProjectModal() {
            const modal = document.getElementById('projectModal');
            const grid = document.getElementById('projectModalGrid');

            // Set grid layout dynamically based on orientation and project count (matching main page)
            const isPortrait = window.innerHeight > window.innerWidth;
            const projectCount = allProjects.length;

            if (isPortrait) {
                if (projectCount > 12) {
                    grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
                    grid.style.gridTemplateRows = 'repeat(5, 1fr)';
                } else {
                    grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
                    grid.style.gridTemplateRows = 'repeat(4, 1fr)';
                }
            } else {
                if (projectCount > 12) {
                    grid.style.gridTemplateColumns = 'repeat(5, 1fr)';
                    grid.style.gridTemplateRows = 'repeat(3, 1fr)';
                } else {
                    grid.style.gridTemplateColumns = 'repeat(4, 1fr)';
                    grid.style.gridTemplateRows = 'repeat(3, 1fr)';
                }
            }

            // Build project grid matching main page style
            let gridHtml = '';
            allProjects.forEach(project => {
                const color = project.color || '#D15540';
                gridHtml += `
                    <div class="project-modal-item"
                         onclick="selectProject(${project.id}, '${project.name.replace(/'/g, "\\'")}', '${color}')">
                        <div class="project-modal-fill" style="background-color: ${color};"></div>
                        <span class="project-modal-label">${project.name}</span>
                    </div>
                `;
            });

            grid.innerHTML = gridHtml;
            modal.classList.add('visible');

            // Add close button handler
            document.getElementById('modalCloseBtn').onclick = hideProjectModal;
        }

        function hideProjectModal() {
            const modal = document.getElementById('projectModal');
            modal.classList.remove('visible');
            pendingTimeRange = null;
            pendingEntryIdForProjectChange = null;

            // Clean up any selection visuals on all minimaps
            const allMinimaps = document.querySelectorAll('.day-minimap');
            allMinimaps.forEach(minimap => {
                const selection = minimap.querySelector('.drag-selection');
                if (selection) {
                    minimap.removeChild(selection);
                }
                removeTimeIndicators(minimap);
            });
        }

        function getEntriesForDate(dateKey) {
            const dayStart = new Date(dateKey + 'T00:00:00');
            const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);

            return allEntries.filter(entry => {
                const entryStart = new Date(entry.start);
                const entryEnd = entry.stop ? new Date(entry.stop) : new Date();
                // Include entries that overlap with this day at all
                return entryStart < dayEnd && entryEnd > dayStart;
            });
        }

        function adjustForOverlaps(startStr, endStr, existingEntries) {
            let newStart = new Date(startStr);
            let newEnd = new Date(endStr);

            for (const entry of existingEntries) {
                const entryStart = new Date(entry.start);
                const entryEnd = entry.stop ? new Date(entry.stop) : new Date();

                if (newStart < entryEnd && newEnd > entryStart) {
                    // Overlap detected - shrink new entry
                    if (entryStart <= newStart && entryEnd >= newEnd) {
                        return null; // Fully covered
                    } else if (entryEnd > newStart && entryEnd < newEnd) {
                        newStart = new Date(entryEnd);
                    } else if (entryStart > newStart && entryStart < newEnd) {
                        newEnd = new Date(entryStart);
                    }
                }
            }

            return newStart >= newEnd ? null : {
                start: newStart.toISOString(),
                end: newEnd.toISOString()
            };
        }

        async function createTimeEntry(projectId, startTime, endTime) {
            const apiKey = getCookie('apiToken');
            if (!apiKey) {
                throw new Error('No API key found');
            }

            // POST to create entry
            const createResponse = await fetch('/api/time-entries', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'X-API-Key': apiKey
                },
                body: JSON.stringify({ project_id: projectId })
            });

            if (!createResponse.ok) {
                throw new Error('Failed to create time entry');
            }

            const newEntry = await createResponse.json();

            // PUT to set times
            const updateResponse = await fetch(`/api/time-entries/${newEntry.id}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'X-API-Key': apiKey
                },
                body: JSON.stringify({
                    start_time: startTime,
                    end_time: endTime
                })
            });

            if (!updateResponse.ok) {
                throw new Error('Failed to update time entry times');
            }

            return await updateResponse.json();
        }

        async function selectProject(projectId, projectName, projectColor) {
            // Handle project change for existing entry
            if (pendingEntryIdForProjectChange) {
                try {
                    const apiKey = getCookie('apiToken');
                    const response = await fetch(`/api/time-entries/${pendingEntryIdForProjectChange}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`,
                            'X-API-Key': apiKey
                        },
                        body: JSON.stringify({ project_id: projectId })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to update project');
                    }

                    hideProjectModal();
                    await loadTimeEntries(true);
                } catch (error) {
                    console.error('Error changing project:', error);
                    alert(`Error changing project: ${error.message}`);
                    hideProjectModal();
                }
                return;
            }

            if (!pendingTimeRange) {
                hideProjectModal();
                return;
            }

            const { startTime, endTime, dateKey } = pendingTimeRange;

            // Get existing entries for overlap check
            const existingEntries = getEntriesForDate(dateKey);
            const adjustedRange = adjustForOverlaps(startTime, endTime, existingEntries);

            if (!adjustedRange) {
                alert('Selected time is fully covered by existing entries.');
                hideProjectModal();
                return;
            }

            try {
                await createTimeEntry(projectId, adjustedRange.start, adjustedRange.end);
                hideProjectModal();
                await loadTimeEntries(true);
            } catch (error) {
                console.error('Error creating time entry:', error);
                alert(`Error creating time entry: ${error.message}`);
                hideProjectModal();
            }
        }

        function changeEntryProject(entryId) {
            pendingEntryIdForProjectChange = entryId;
            pendingTimeRange = null;
            showProjectModal();
        }

        async function splitTimeEntry(entryId) {
            const entry = allEntries.find(e => e.id === entryId);
            if (!entry || !entry.stop || entry.duration < 0) {
                alert('Cannot split a running entry.');
                return;
            }

            const startTime = new Date(entry.start);
            const endTime = new Date(entry.stop);
            const midTime = new Date((startTime.getTime() + endTime.getTime()) / 2);

            const apiKey = getCookie('apiToken');
            if (!apiKey) {
                alert('No API key found.');
                return;
            }

            try {
                // Update original entry to end at midpoint
                const updateResponse = await fetch(`/api/time-entries/${entryId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`,
                        'X-API-Key': apiKey
                    },
                    body: JSON.stringify({
                        end_time: midTime.toISOString()
                    })
                });

                if (!updateResponse.ok) {
                    throw new Error('Failed to update original entry');
                }

                // Create new entry from midpoint to end with same project
                // First get the project_id from the entry
                const projectName = entry.name;
                const project = allProjects.find(p => p.name === projectName);
                if (!project) {
                    throw new Error('Project not found');
                }

                await createTimeEntry(project.id, midTime.toISOString(), endTime.toISOString());
                await loadTimeEntries(true);
            } catch (error) {
                console.error('Error splitting entry:', error);
                alert(`Error splitting entry: ${error.message}`);
            }
        }

        // Load projects first to get colors, then load time entries
        fetchProjects().then(async () => {
            // Also fetch full project list for modal
            try {
                const response = await fetch('/api/projects', { headers: getApiHeaders() });
                if (response.ok) {
                    allProjects = await response.json();
                }
            } catch (error) {
                console.error('Error fetching projects for modal:', error);
            }
            getCurrentTask();
            loadTimeEntries();
        });

        // WebSocket connection for real-time updates
        let ws = null;
        let wsReconnectTimeout = null;

        function connectWebSocket() {
            const apiKey = getCookie('apiToken');
            if (!apiKey) return;

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}?api_key=${apiKey}`;

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
            };

            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleWebSocketMessage(message);
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                }
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                ws = null;
                wsReconnectTimeout = setTimeout(connectWebSocket, 2000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        function handleWebSocketMessage(message) {
            console.log('WebSocket message:', message.type);

            switch (message.type) {
                case 'project_created':
                case 'project_updated':
                case 'project_deleted':
                    // Refresh projects list
                    fetchProjects().then(async () => {
                        try {
                            const response = await fetch('/api/projects', { headers: getApiHeaders() });
                            if (response.ok) {
                                allProjects = await response.json();
                            }
                        } catch (error) {
                            console.error('Error fetching projects for modal:', error);
                        }
                        loadTimeEntries(true);
                    });
                    break;

                case 'time_entry_started':
                case 'time_entry_stopped':
                    // Update current task for title ticker and reload entries
                    getCurrentTask();
                    loadTimeEntries(true);
                    break;

                case 'time_entry_updated':
                case 'time_entry_deleted':
                    // Reload time entries, preserving current page
                    getCurrentTask();
                    loadTimeEntries(true);
                    break;
            }
        }

        // Connect WebSocket
        connectWebSocket();

        // Set up interval to update running entries every second
        let runningEntriesInterval = setInterval(updateRunningEntries, 1000);

        // Set up interval to update document title every second
        setInterval(updateDocumentTitle, 1000);
        updateDocumentTitle();

        // Refresh data when tab becomes visible again (e.g., laptop wakes up)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                getCurrentTask();
                loadTimeEntries(true);
            }
        });

        // Navigate to main page on Escape key (or close modal if open)
        // Use capture phase and window to ensure it works regardless of focus
        window.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' || event.keyCode === 27) {
                const modal = document.getElementById('projectModal');
                if (modal && modal.classList.contains('visible')) {
                    event.preventDefault();
                    event.stopPropagation();
                    hideProjectModal();
                } else {
                    event.preventDefault();
                    event.stopPropagation();
                    window.location.href = '/';
                }
            }
        }, true);

        // Navigate between weeks with left/right arrow keys
        window.addEventListener('keydown', function(event) {
            // Don't trigger if a modal is open or user is typing in an input
            const modal = document.getElementById('projectModal');
            if (modal && modal.classList.contains('visible')) return;
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;

            const daysPerPage = 7;
            const totalPages = Math.ceil(allUniqueDates.length / daysPerPage);

            if (event.key === 'ArrowLeft') {
                event.preventDefault();
                if (currentPage < totalPages) {
                    goToPage(currentPage + 1);
                }
            } else if (event.key === 'ArrowRight') {
                event.preventDefault();
                if (currentPage > 1) {
                    goToPage(currentPage - 1);
                }
            }
        });
    </script>
</body>
</html>

