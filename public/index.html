<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Clock-Out</title>
    <link rel="stylesheet" href="style.css">
    <link rel="apple-touch-icon" sizes="180x180" href="icon.png">
    <link rel="icon" href="icon.png" sizes="any">
</head>

<body>
    <div class="time-adjust-nav">
        <button id="addTenButton" onclick="addTenMinutes()">10m</button>
        <button id="addThirtyButton" onclick="addThirtyMinutes()">30m</button>
        <button id="addHourButton" onclick="addOneHour()">1h</button>
    </div>
    <div class="page-nav">
        <a href="/" title="Track">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
                <path fill-rule="evenodd" d="M3 6a3 3 0 0 1 3-3h2.25a3 3 0 0 1 3 3v2.25a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3V6Zm9.75 0a3 3 0 0 1 3-3H18a3 3 0 0 1 3 3v2.25a3 3 0 0 1-3 3h-2.25a3 3 0 0 1-3-3V6ZM3 15.75a3 3 0 0 1 3-3h2.25a3 3 0 0 1 3 3V18a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3v-2.25Zm9.75 0a3 3 0 0 1 3-3H18a3 3 0 0 1 3 3V18a3 3 0 0 1-3 3h-2.25a3 3 0 0 1-3-3v-2.25Z" clip-rule="evenodd"/>
            </svg>
        </a>
        <a href="/history" title="History">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
                <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 0 1 7.5 3v1.5h9V3A.75.75 0 0 1 18 3v1.5h.75a3 3 0 0 1 3 3v11.25a3 3 0 0 1-3 3H5.25a3 3 0 0 1-3-3V7.5a3 3 0 0 1 3-3H6V3a.75.75 0 0 1 .75-.75Zm13.5 9a1.5 1.5 0 0 0-1.5-1.5H5.25a1.5 1.5 0 0 0-1.5 1.5v7.5a1.5 1.5 0 0 0 1.5 1.5h13.5a1.5 1.5 0 0 0 1.5-1.5v-7.5Z" clip-rule="evenodd"/>
            </svg>
        </a>
        <a href="/settings" title="Settings">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
                <path fill-rule="evenodd" d="M12 6.75a5.25 5.25 0 0 1 6.775-5.025.75.75 0 0 1 .313 1.248l-3.32 3.319c.063.475.276.934.641 1.299.365.365.824.578 1.3.64l3.318-3.319a.75.75 0 0 1 1.248.313 5.25 5.25 0 0 1-5.472 6.756c-1.018-.086-1.87.1-2.309.634L7.344 21.3A3.298 3.298 0 1 1 2.7 16.657l8.684-7.151c.533-.44.72-1.291.634-2.309A5.342 5.342 0 0 1 12 6.75ZM4.117 19.125a.75.75 0 0 1 .75-.75h.008a.75.75 0 0 1 .75.75v.008a.75.75 0 0 1-.75.75h-.008a.75.75 0 0 1-.75-.75v-.008Z" clip-rule="evenodd"/>
            </svg>
        </a>
    </div>
    <div id="untrackedIndicator" class="untracked-indicator">
        <span id="untrackedText">--:--</span>
    </div>
    <div class="grid" id="taskGrid"></div>
    <script>
        let projects = [];
        let currentTaskId = null;
        let currentTaskStartTime = null;
        let currentTaskName = null;
        let cachedProjectTotals = {};
        let cachedProjectDays = {}; // Maps project name to array of 7 booleans (index 0 = 7 days ago, index 6 = today)
        let cachedTotalHours = 0;
        let totalsLastUpdatedAt = null;
        let currentTaskElapsedAtLastUpdateHours = 0;
        let totalsUpdateInFlight = false;
        const TOTALS_REFRESH_INTERVAL_MS = 15 * 60 * 1000;
        const DEFAULT_TITLE = document.title;
        let apiToken = getCookie('apiToken') || '';

        function getApiHeaders() {
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiToken}`,
                'X-API-Key': apiToken
            };
        }

        function getAdjustedTotals() {
            const totals = { ...cachedProjectTotals };
            let totalHours = cachedTotalHours;

            if (currentTaskName && currentTaskStartTime) {
                const now = Date.now();
                const windowStart = now - 168 * 60 * 60 * 1000;
                // Clamp start time to window start
                const effectiveStart = Math.max(currentTaskStartTime.getTime(), windowStart);
                const currentElapsedHours = (now - effectiveStart) / 3600000;

                // Calculate elapsed at last update, also clamped to window
                const effectiveStartAtUpdate = Math.max(currentTaskStartTime.getTime(), windowStart);
                const elapsedAtUpdateClamped = totalsLastUpdatedAt
                    ? Math.max(0, (totalsLastUpdatedAt - effectiveStartAtUpdate) / 3600000)
                    : 0;

                const delta = Math.max(0, currentElapsedHours - elapsedAtUpdateClamped);
                totals[currentTaskName] = (totals[currentTaskName] || 0) + delta;
                totalHours += delta;
            }

            return { totals, totalHours };
        }

        function renderProjectTotals(projectTotals) {
            projects.forEach(project => {
                const target = project.target_hours || project.targetTime;
                const total = projectTotals[project.name] || 0;
                const ratio = Math.max(0, Math.min(total / target, 2));
                const label = document.getElementById(project.name);
                if (!label) {
                    return;
                }
                const fill = label.previousElementSibling;
                fill.style.height = `${ratio * 50}%`;

                const difference = Math.round(total - target);

                const offset = label.nextElementSibling;
                if (Math.abs(difference) > 0) {
                    offset.innerText = difference > 0 ? `+${difference}` : `${difference}`;
                    offset.style.left = difference < 0 ? '1em' : 'auto';
                    offset.style.right = difference > 0 ? '1em' : 'auto';
                } else {
                    offset.innerText = '';
                }
            });
        }

        function renderUntracked(totalHours) {
            const totalWeekHours = 168;
            const trackedHours = totalHours;
            const untrackedHours = Math.max(0, totalWeekHours - trackedHours);

            const hours = Math.floor(untrackedHours);
            const minutes = Math.round((untrackedHours - hours) * 60);

            const untrackedText = document.getElementById('untrackedText');
            const untrackedIndicator = document.getElementById('untrackedIndicator');

            if (untrackedHours > 1) {
                untrackedText.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                untrackedIndicator.style.display = 'block';
            } else {
                untrackedIndicator.style.display = 'none';
            }
        }

        function formatElapsedDuration(durationSeconds) {
            const totalSeconds = Math.max(0, Math.floor(durationSeconds));
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            const totalMinutes = Math.floor(totalSeconds / 60);
            return `${totalMinutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateDocumentTitle() {
            if (currentTaskName && currentTaskStartTime instanceof Date) {
                const elapsedSeconds = (Date.now() - currentTaskStartTime.getTime()) / 1000;
                const formattedDuration = formatElapsedDuration(elapsedSeconds);
                document.title = `${formattedDuration} ${currentTaskName}`;
                return;
            }
            document.title = DEFAULT_TITLE;
        }

        function renderTotalsFromCache() {
            if (!projects.length) {
                return;
            }
            const { totals, totalHours } = getAdjustedTotals();
            renderProjectTotals(totals);
            renderDayIndicators();
            renderUntracked(totalHours);
        }

        function renderDayIndicators() {
            projects.forEach(project => {
                const indicator = document.getElementById(`days-${project.name}`);
                if (!indicator) return;

                let days = cachedProjectDays[project.name] || [false, false, false, false, false, false, false];

                // If this project is currently running, mark today as active
                if (currentTaskName === project.name) {
                    days = [...days];
                    days[6] = true;
                }

                const symbols = days.map(active => active ? '◉' : '◯').join('');
                indicator.textContent = symbols;
            });
        }


        async function fetchProjects() {
            if (!apiToken) {
                projects = [];
                generateTaskContainers();
                return;
            }

            try {
                const response = await fetch('/api/projects', {
                    headers: getApiHeaders()
                });

                if (response.status === 401) {
                    console.error('Invalid API key');
                    projects = [];
                    generateTaskContainers();
                    return;
                }

                if (!response.ok) {
                    throw new Error(`Failed to fetch projects: ${response.status}`);
                }

                const data = await response.json();
                projects = data.map(project => ({
                    id: project.id,
                    name: project.name,
                    targetTime: project.target_hours,
                    color: project.color || '#D15540'
                })).sort((a, b) => b.targetTime - a.targetTime);

                generateTaskContainers();
                getCurrentTask().then(() => {
                    updateTotals();
                });
            } catch (error) {
                console.error('Error fetching projects:', error);
                projects = [];
                generateTaskContainers();
            }
        }

        function generateTaskContainers() {
            const taskGrid = document.getElementById('taskGrid');
            taskGrid.innerHTML = '';

            const totalTargetHours = projects.reduce((sum, project) => sum + project.targetTime, 0);
            console.log(`Total target hours: ${totalTargetHours}`);

            if (totalTargetHours !== 168) {
                console.warn(`Warning: Total target hours (${totalTargetHours}) is not equal to 168.`);
            }

            const isPortrait = window.innerHeight > window.innerWidth;
            const projectCount = projects.length;

            if (isPortrait) {
                if (projectCount > 12) {
                    taskGrid.style.gridTemplateColumns = 'repeat(3, 1fr)';
                    taskGrid.style.gridTemplateRows = 'repeat(5, 1fr)';
                } else {
                    taskGrid.style.gridTemplateColumns = 'repeat(3, 1fr)';
                    taskGrid.style.gridTemplateRows = 'repeat(4, 1fr)';
                }
            } else {
                if (projectCount > 12) {
                    taskGrid.style.gridTemplateColumns = 'repeat(5, 1fr)';
                    taskGrid.style.gridTemplateRows = 'repeat(3, 1fr)';
                } else {
                    taskGrid.style.gridTemplateColumns = 'repeat(4, 1fr)';
                    taskGrid.style.gridTemplateRows = 'repeat(3, 1fr)';
                }
            }

            projects.forEach((project) => {
                const container = document.createElement('div');
                container.className = 'container';
                container.onclick = () => startTask(project.id, project.name);

                const fill = document.createElement('div');
                fill.className = 'fill';
                fill.style.backgroundColor = project.color;

                const label = document.createElement('span');
                label.className = 'label';
                label.id = project.name;
                label.textContent = project.name;

                const offset = document.createElement('span');
                offset.className = 'offset';

                const dayIndicator = document.createElement('span');
                dayIndicator.className = 'day-indicator';
                dayIndicator.id = `days-${project.name}`;
                dayIndicator.textContent = '◯◯◯◯◯◯◯';

                container.appendChild(fill);
                container.appendChild(label);
                container.appendChild(offset);
                container.appendChild(dayIndicator);

                taskGrid.appendChild(container);
            });
            renderTotalsFromCache();
        }

        async function getCurrentTask() {
            if (!apiToken) {
                currentTaskId = null;
                currentTaskName = null;
                currentTaskStartTime = null;
                currentTaskElapsedAtLastUpdateHours = 0;
                updateButtonStyles(null);
                renderTotalsFromCache();
                updateDocumentTitle();
                return;
            }

            try {
                const response = await fetch('/api/time-entries/current', {
                    headers: getApiHeaders()
                });

                if (response.status === 401) {
                    throw new Error('Invalid API key');
                }

                if (!response.ok) {
                    throw new Error(`Failed to fetch current task: ${response.status}`);
                }

                const data = await response.json();
                if (data && data.id) {
                    currentTaskId = data.id;
                    currentTaskName = data.name;
                    currentTaskStartTime = data.start ? new Date(data.start) : null;
                    if (currentTaskStartTime && totalsLastUpdatedAt) {
                        currentTaskElapsedAtLastUpdateHours = Math.max(0, (totalsLastUpdatedAt - currentTaskStartTime.getTime()) / 3600000);
                    } else {
                        currentTaskElapsedAtLastUpdateHours = 0;
                    }
                    if (currentTaskName && !(currentTaskName in cachedProjectTotals)) {
                        cachedProjectTotals[currentTaskName] = 0;
                    }
                    updateButtonStyles(currentTaskName);
                    renderTotalsFromCache();
                    updateDocumentTitle();
                } else {
                    currentTaskId = null;
                    currentTaskName = null;
                    currentTaskStartTime = null;
                    currentTaskElapsedAtLastUpdateHours = 0;
                    updateButtonStyles(null);
                    renderTotalsFromCache();
                    updateDocumentTitle();
                }
            } catch (error) {
                console.error('Error getting current task:', error);
                currentTaskId = null;
                currentTaskName = null;
                currentTaskStartTime = null;
                currentTaskElapsedAtLastUpdateHours = 0;
                updateButtonStyles(null);
                renderTotalsFromCache();
                updateDocumentTitle();
            }
        }

        async function updateTotals() {
            if (totalsUpdateInFlight || !apiToken) {
                return;
            }
            totalsUpdateInFlight = true;
            try {
                const response = await fetch('/api/time-entries', {
                    headers: getApiHeaders()
                });

                if (response.status === 401) {
                    throw new Error('Invalid API key');
                }

                if (!response.ok) {
                    throw new Error(`Failed to fetch time entries: ${response.status}`);
                }

                const timeEntries = await response.json();

                let totalHours = 0;
                let projectTimes = {};
                let projectDays = {}; // Maps project name to Set of day indices (0-6)
                const now = new Date();
                const windowStart = new Date(now.getTime() - 168 * 60 * 60 * 1000);

                // Calculate midnight boundaries for the last 7 days
                const todayMidnight = new Date(now);
                todayMidnight.setHours(0, 0, 0, 0);
                const dayBoundaries = [];
                for (let i = 6; i >= 0; i--) {
                    const dayStart = new Date(todayMidnight.getTime() - i * 24 * 60 * 60 * 1000);
                    const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);
                    dayBoundaries.push({ start: dayStart, end: dayEnd, index: 6 - i });
                }

                timeEntries.forEach(entry => {
                    const start = new Date(entry.start);
                    const end = entry.duration < 0 ? now : new Date(entry.stop);

                    // Calculate effective start (clamp to window start)
                    const effectiveStart = start < windowStart ? windowStart : start;

                    // Only count time within the 168-hour window
                    const durationMs = Math.max(0, end.getTime() - effectiveStart.getTime());
                    const durationHours = durationMs / 3600000;

                    totalHours += durationHours;
                    const projectName = entry.name;
                    if (projectName) {
                        if (projectTimes[projectName]) {
                            projectTimes[projectName] += durationHours;
                        } else {
                            projectTimes[projectName] = durationHours;
                        }

                        // Check which days this entry spans
                        if (!projectDays[projectName]) {
                            projectDays[projectName] = new Set();
                        }
                        dayBoundaries.forEach(day => {
                            // Entry overlaps with day if entry.start < day.end AND entry.end > day.start
                            if (start < day.end && end > day.start) {
                                projectDays[projectName].add(day.index);
                            }
                        });
                    }
                });

                cachedProjectTotals = projectTimes;
                // Convert Sets to arrays of booleans
                cachedProjectDays = {};
                for (const projectName in projectDays) {
                    cachedProjectDays[projectName] = Array.from({ length: 7 }, (_, i) => projectDays[projectName].has(i));
                }
                cachedTotalHours = totalHours;
                totalsLastUpdatedAt = Date.now();
                if (currentTaskStartTime) {
                    currentTaskElapsedAtLastUpdateHours = Math.max(0, (totalsLastUpdatedAt - currentTaskStartTime.getTime()) / 3600000);
                } else {
                    currentTaskElapsedAtLastUpdateHours = 0;
                }
                renderTotalsFromCache();
            } catch (error) {
                console.error('Error updating totals:', error);
            } finally {
                totalsUpdateInFlight = false;
            }
        }

        setInterval(() => {
            renderTotalsFromCache();
            if (!totalsLastUpdatedAt || (Date.now() - totalsLastUpdatedAt) >= TOTALS_REFRESH_INTERVAL_MS) {
                updateTotals();
            }
        }, 60 * 1000);

        setInterval(updateDocumentTitle, 1000);
        updateDocumentTitle();

        async function startTask(projectId, projectName) {
            if (!apiToken) {
                alert('Please enter an API key in settings first.');
                return;
            }

            // If clicking the same task that's running, stop it
            if (currentTaskId && currentTaskName === projectName) {
                await stopCurrentTask();
                return;
            }

            try {
                const response = await fetch('/api/time-entries', {
                    method: 'POST',
                    headers: getApiHeaders(),
                    body: JSON.stringify({
                        project_id: projectId
                    })
                });

                if (response.status === 401) {
                    alert('Invalid API key.');
                    return;
                }

                if (!response.ok) {
                    const error = await response.json();
                    alert(error.error || 'Failed to start task.');
                    return;
                }

                const data = await response.json();
                currentTaskId = data.id;
                currentTaskName = projectName;
                currentTaskStartTime = data.start ? new Date(data.start) : new Date();
                if (!(projectName in cachedProjectTotals)) {
                    cachedProjectTotals[projectName] = 0;
                }
                currentTaskElapsedAtLastUpdateHours = totalsLastUpdatedAt && currentTaskStartTime
                    ? Math.max(0, (totalsLastUpdatedAt - currentTaskStartTime.getTime()) / 3600000)
                    : 0;
                renderTotalsFromCache();
                updateButtonStyles(projectName);
                updateDocumentTitle();
            } catch (error) {
                console.error('Error starting task:', error);
                alert('Error starting task.');
            }
        }

        async function stopCurrentTask() {
            if (!apiToken || !currentTaskId) {
                return;
            }

            try {
                const response = await fetch(`/api/time-entries/${currentTaskId}/stop`, {
                    method: 'PATCH',
                    headers: getApiHeaders()
                });

                if (response.status === 401) {
                    throw new Error('Invalid API key');
                }

                if (!response.ok) {
                    throw new Error('Failed to stop task');
                }

                currentTaskId = null;
                currentTaskName = null;
                currentTaskStartTime = null;
                currentTaskElapsedAtLastUpdateHours = 0;
                renderTotalsFromCache();
                updateButtonStyles(null);
                updateDocumentTitle();
            } catch (error) {
                console.error('Error stopping task:', error);
                alert('Error stopping task.');
            }
        }

        function updateButtonStyles(activeTask) {
            const buttons = document.querySelectorAll('.container');
            buttons.forEach(button => {
                const taskName = button.querySelector('.label').innerText;
                if (taskName === activeTask) {
                    button.style.opacity = '1';
                } else {
                    button.style.opacity = '0.4';
                }
            });
        }

        function setCookie(name, value, days) {
            const d = new Date();
            d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
            const expires = "expires=" + d.toUTCString();
            document.cookie = name + "=" + value + ";" + expires + ";path=/";
        }

        function getCookie(name) {
            const cname = name + "=";
            const decodedCookie = decodeURIComponent(document.cookie);
            const ca = decodedCookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(cname) === 0) {
                    return c.substring(cname.length, c.length);
                }
            }
            return "";
        }

        if (apiToken) {
            fetchProjects();
        }

        // Handle Escape key to navigate to history page
        // Use capture phase and window to ensure it works regardless of focus
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' || event.keyCode === 27) {
                event.preventDefault();
                event.stopPropagation();
                window.location.href = '/history';
            }
        }, true);

        async function fetchRecentEntries() {
            if (!apiToken) return [];
            try {
                const response = await fetch('/api/time-entries?all=true', {
                    headers: getApiHeaders()
                });
                if (!response.ok) return [];
                return await response.json();
            } catch (error) {
                console.error('Error fetching entries:', error);
                return [];
            }
        }

        async function addTimeToCurrentTask(minutes) {
            if (!apiToken) {
                alert('Please enter an API key in settings first.');
                return;
            }

            const allEntries = await fetchRecentEntries();
            if (allEntries.length === 0) {
                alert('No time entries found.');
                return;
            }

            const currentEntry = allEntries[0];
            const previousEntry = allEntries.length > 1 ? allEntries[1] : null;

            if (!currentEntry) {
                alert('No current time entry found.');
                return;
            }

            try {
                const currentStartTime = new Date(currentEntry.start);
                const newCurrentStartTime = new Date(currentStartTime.getTime() - minutes * 60 * 1000);

                const currentResponse = await fetch(`/api/time-entries/${currentEntry.id}`, {
                    method: 'PUT',
                    headers: getApiHeaders(),
                    body: JSON.stringify({
                        start_time: newCurrentStartTime.toISOString()
                    })
                });

                if (!currentResponse.ok) {
                    const errorData = await currentResponse.json();
                    throw new Error(errorData.error || 'Failed to update current entry');
                }

                if (previousEntry && previousEntry.stop) {
                    const previousEndTime = new Date(previousEntry.stop);
                    const newPreviousEndTime = new Date(previousEndTime.getTime() - minutes * 60 * 1000);

                    await fetch(`/api/time-entries/${previousEntry.id}`, {
                        method: 'PUT',
                        headers: getApiHeaders(),
                        body: JSON.stringify({
                            end_time: newPreviousEndTime.toISOString()
                        })
                    });
                }

                await updateTotals();
            } catch (error) {
                console.error('Error adding time:', error);
                alert(`Error adding time: ${error.message}`);
            }
        }

        async function addTenMinutes() {
            const button = document.getElementById('addTenButton');
            button.disabled = true;
            await addTimeToCurrentTask(10);
            button.disabled = false;
        }

        async function addThirtyMinutes() {
            const button = document.getElementById('addThirtyButton');
            button.disabled = true;
            await addTimeToCurrentTask(30);
            button.disabled = false;
        }

        async function addOneHour() {
            const button = document.getElementById('addHourButton');
            button.disabled = true;
            await addTimeToCurrentTask(60);
            button.disabled = false;
        }
    </script>
</body>

</html>
